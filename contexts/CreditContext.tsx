'use client';import { createContext, useContext, useEffect, useState, useCallback } from 'react';import { createClientComponentClient } from '@/lib/supabase';import { useAuth } from './AuthContext';interface CreditInfo {  creditsUsed: number;  creditLimit: number;  isSubscribed: boolean;  subscriptionTier: string | null;  creditType: 'lifetime' | 'monthly';  creditsRemaining: number;}interface CreditContextValue {  creditInfo: CreditInfo | null;  loading: boolean;  refreshCredits: () => Promise<void>;}const CreditContext = createContext<CreditContextValue>({  creditInfo: null,  loading: true,  refreshCredits: async () => {},});export function CreditProvider({ children }: { children: React.ReactNode }) {  const { user } = useAuth();  const [creditInfo, setCreditInfo] = useState<CreditInfo | null>(null);  const [loading, setLoading] = useState(true);  const supabase = createClientComponentClient();  const refreshCredits = useCallback(async () => {    if (!user?.id) {      setCreditInfo(null);      setLoading(false);      return;    }    try {      const { data: profile } = await supabase        .from('profiles')        .select('subscription_tier, subscription_status, lifetime_credits_granted, lifetime_credits_used, monthly_credits, monthly_credits_used')        .eq('id', user.id)        .single();      if (profile) {        const isSubscribed = profile.subscription_status === 'active';        const creditType = isSubscribed ? 'monthly' : 'lifetime';        const creditsUsed = isSubscribed           ? (profile.monthly_credits_used ?? 0)          : (profile.lifetime_credits_used ?? 0);        const creditLimit = isSubscribed           ? (profile.monthly_credits ?? 0)          : (profile.lifetime_credits_granted ?? 6);        setCreditInfo({          creditsUsed,          creditLimit,          isSubscribed,          subscriptionTier: profile.subscription_tier,          creditType,          creditsRemaining: Math.max(0, creditLimit - creditsUsed),        });      }    } catch (error) {    } finally {      setLoading(false);    }  }, [user?.id, supabase]);  // Initial load and setup real-time subscription  useEffect(() => {    if (!user?.id) {      setCreditInfo(null);      setLoading(false);      return;    }    // Initial fetch    refreshCredits();    // Set up real-time subscription    const channel = supabase      .channel(`credit-updates-${user.id}`)      .on(        'postgres_changes',        {          event: '*',          schema: 'public',          table: 'profiles',          filter: `id=eq.${user.id}`,        },        (payload) => {          refreshCredits();        }      )      .subscribe();    // Poll every 30 seconds as fallback    const interval = setInterval(refreshCredits, 30000);    return () => {      channel.unsubscribe();      clearInterval(interval);    };  }, [user?.id, refreshCredits, supabase]);  // Refresh credits after any generation  useEffect(() => {    const handleCreditUsed = () => {      refreshCredits();    };    window.addEventListener('creditUsed', handleCreditUsed);    return () => window.removeEventListener('creditUsed', handleCreditUsed);  }, [refreshCredits]);  return (    <CreditContext.Provider value={{ creditInfo, loading, refreshCredits }}>      {children}    </CreditContext.Provider>  );}export const useCredits = () => {  const context = useContext(CreditContext);  if (!context) {    throw new Error('useCredits must be used within a CreditProvider');  }  return context;};export const useSubscription = () => {  const { creditInfo, loading } = useCredits();  return {    tier: creditInfo?.isSubscribed ? (creditInfo?.subscriptionTier as 'starter' | 'pro') : null,    isSubscribed: creditInfo?.isSubscribed ?? false,    loading,  } as const;};